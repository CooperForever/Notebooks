# 1-10
## 1. Ajax-Fetch-Axios 
### 三者有何区别
- Ajax 是一种技术统称
- Fetch是具体的API
  - **使用方式**
   ```js
   fetch(url)
  .then((res) => res.json())
  .then((data) => console.log(data))
  .catch((e) => console.log('error'))
   ```
  - **优势**:
     1. 基于 Promise，编程友好     
     2. 关注点分离，API分散在对个对象上（Response 对象、Request 对象、Headers 对象）
  - **Fetch与XHR区别**：
     1. fetch返回的promise不会拒绝HTTP的错误状态，如404或500，此类错误会别标记为resolve, 只有网络错误或请求被组织时,才会标记reject。
     2. fetch不会发送跨域cookies
- Axios是第三方库    
### 封装XHR
```js
function ajax(options) {
    let { type = "get", url, success, error, timeout, headers, requestData = null, responseType } = options
    const xhr = new XMLHttpRequest()
    xhr.open(type.toLowerCase(), url, false)

    if (headers) {
        headers.forEach((val, key) => {
            xhr.setRequestHeader(key, val);
        });
    }
    if (timeout) {
        xhr.timeout = timeout
    }
    if (responseType) {
        xhr.responseType = responseType
    }
    if (typeof progress == "function") {
        xhr.addEventListener('load', success)
    }
    if (typeof progress == "function") {
        xhr.addEventListener('error', success)
    }

    if (typeof progress == "function") {
        xhr.addEventListener('progress', processCallBack)
    }

    xhr.send(requestData)
}
ssh-keygen -t rsa -C  cooperforver@163.com

```

## 2. 判断数据类型
### typeof
`typeof` 操作符返回一个字符串，表示未经计算的操作数的类型。
| 类型                 | 结果        |
| -------------------- | ----------- |
| Undefined            | 'undefined' |
| Null                 | 'object'    |
| Boolean              | 'boolean'   |
| Bumber               | 'number'    |
| BigInt               | 'bigint'    |
| String               | 'string'    |
| Sytmbol              | 'symbol'    |
| Function(非箭头函数) | 'function'  |
| [],{}(其他任何对象)  | 'object'    |

### instanceOf
`instanceof` 运算符用于检测构造函数的 `prototype` 属性是否出现在某个实例对象的原型链上。
```js
[] instanceof Array // true
[] instanceof Object // true
```
### Object.prototype.toString
`toString()` 方法返回一个表示该对象的字符串。
```js
function fn(){}

Object.prototype.toString.call(1)  // '[object Number]'
Object.prototype.toString.call('')  // '[object String]'
Object.prototype.toString.call(1n)  // '[object BigInt]'
Object.prototype.toString.call(true)  // '[object Boolean]'
Object.prototype.toString.call(null)  // '[object Null]'
Object.prototype.toString.call(undefined)  // '[object Undefined]'
Object.prototype.toString.call(Symbol(1))  // '[object Symbol]'
Object.prototype.toString.call([])  // '[object Array]'
Object.prototype.toString.call({})  // '[object Object]'
Object.prototype.toString.call(()=>{}) // '[object Function]'
Object.prototype.toString.call(fn) // '[object Function]'
Object.prototype.toString.call(new Map()) //'[object Map]'
Object.prototype.toString.call(new WeakMap()) //'[object WeakMap]'
Object.prototype.toString.call(new Set()) //'[object Set]'
Object.prototype.toString.call(new Date()) //'[object Date]'

```
**总结：** 判断类型最全的方法是`Object.prototype.toString`，检测是否是实例对象用`instanceof`。
## 防抖和节流
### 两者的区别
**防抖：** 先操作，啥时候停了或者间歇满足时间，再执行下一布
```js
// debounce
function debounce(fn,delay = 200){
   let timer  = 0

   return function(){
      if(timer){
         clearTimeout(timer)
      }
      timer = setTimeout(()=>{
         fn.apply(this,arguments)
         timer = 0
      },delay)
   }
}
```
**节流：** 按时间间隔触发回调,不满足间隔内不触发
```js
function throttle(fn,delay=200){
   let timer = 0
   return function(){
      if(timer) return
      timer = setTimeout(()=>{
         fn.apply(this,arguments)
         timer = 0
      },delay)
   }
}
```
### 适用场景
防抖：
1. 浏览器窗口缩放
2. 表单按钮提交事件
3. input搜索输入框
节流：
1. scroll、drag事件

## px % em rem vw/vh 的区别
- px是基本单位，绝对单位
- % 是相对于父元素的宽度比例
- em 在 font-size 中使用是相对于父元素的字体大小，在其他属性中使用是相对于自身的字体大小
- rem 根元素font-size 相对大小
- vw 屏幕宽度的1%
- vh 屏幕最高的1%
- vmin 两者的最小值，vmax的最大值

## 箭头函数缺点
1. 箭头函数没有arguments
2. 无法通过`apply`,`call`,`bind`改变this，箭头函数this永远指向父作用域
3. 对象方法中不能使用箭头函数
4. 原型方法扩展不能使用箭头函数
5. 构造函数不能使用箭头函数
6. 动态上下文中的回调函数，如`addEventListener`
7. Vue生命周期与method 